import copy
from enum import Enum
from dataclasses import dataclass, field, asdict, is_dataclass, fields
from typing import Union, Tuple, List


# https://stackoverflow.com/questions/53376099/python-dataclass-from-a-nested-dict
def is_dataclass_instance(obj):
    return is_dataclass(obj) and not isinstance(obj, type)

def to_dict(obj):
    """
    Convert a dataclass object to a dict, replace any value of Enum instance to be the value of the item,
    and any value of dataclass object with a dict of {"type": classname, "params": dict}

    Parameters
    ----------
    d : dataclass
    
    Returns
    -------
    dict : resulting dictionary
    """
    if is_dataclass_instance(obj):
        result = []
        for f in fields(obj):
            value = to_dict(getattr(obj, f.name))
            result.append((f.name, value))
        return {"dataclass_type": type(obj).__name__, "params": dict(result)}
    elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
        return type(obj)(*[to_dict(v) for v in obj])
    elif isinstance(obj, (list, tuple)):
        return type(obj)(to_dict(v) for v in obj)
    elif isinstance(obj, dict):
        return type(obj)((to_dict(k),
                          to_dict(v))
                         for k, v in obj.items())
    elif isinstance(obj, Enum):
        return {"enum_type": type(obj).__name__, "value": obj.value}
    else:
        return copy.deepcopy(obj)
    # a = {}
    # for k, v in d.__annotations__.items():
    #     n = getattr(d, k)
    #     if is_dataclass(n):
    #         a[k] = {"dataclass_type": type(n).__name__, "params": to_dict(n)}
    #     elif isinstance(n, Enum):
    #         a[k] = n.value
    #     else:
    #         a[k] = n

def from_dict(obj):
    # reconstruct the dataclass using the type tag
    #if is_dataclass_dict(obj):
    if isinstance(obj, dict):
        if 'dataclass_type' in obj:
            result = {}
            dataclass_type = obj.pop('dataclass_type')
            for name, data in obj['params'].items():
                result[name] = from_dict(data)
            return eval(dataclass_type)(**result)
        elif 'enum_type' in obj:
            return eval(obj['enum_type'])(obj['value'])
        else:
            return type(obj)((from_dict(k), from_dict(v))
                         for k, v in obj.items())
    # exactly the same as before (without the tuple clause)
    elif isinstance(obj, (list, tuple)):
        return type(obj)(from_dict(v) for v in obj)
    else:
        return copy.deepcopy(obj)


class PointMaps(Enum):
    AlbersProjectionMap = 1
    EquidistantProjectionMap = 2
    EulerAnglesMap = 3
    SphereToSphereMap = 4
    SphereToCylinderMap = 5
    CylinderToImageMap = 6
    EyeToSphereToImageMap = 7
    EyeToCylinderToImageMap = 8

class ScreenType(Enum):
    CylinderScreen = 1
    SphereScreen = 2

@dataclass
class CylinderScreen:
    """ Class for configuration of Cylinder screen """
    columns: int = 200     # number of columns on cylinder
    parallels: int = 200   # number of parallels on cylinder
    radius: float = 10.0     # cylinder radius
    # (suggested: at least twice the radius)
    height: float = 20.0     # cylinder height
    image_map: PointMaps = PointMaps.CylinderToImageMap


@dataclass
class SphereScreen:
    """ Class for configuration of Sphere screen """
    parallels: int = 50      # number of parallels on sphere
    meridians: int = 800     # number of meridians on sphere
    radius: float = 10.0       # cylinder radius
    half: bool = True
    image_map: PointMaps = PointMaps.AlbersProjectionMap


class InputType(Enum):
    Ball =  1
    Bar = 2
    FlickerStep = 3
    Natural = 4
    Gratings = 5


@dataclass
class IntensityLevels:
    min: float
    max: float

@dataclass
class InputConfigure:
    shape: Tuple[int, int] = (128, 128)

@dataclass
class InputBallConfigure(InputConfigure):
    center: str = 'center'
    levels: IntensityLevels = IntensityLevels(min = 3e3, max = 3e5)
    speed: float = 1000.0
    white_back: bool = False

@dataclass
class InputBarConfigure(InputConfigure):
    # width in pixels
    bar_width: int = 16
    # direction v vertical, h horizontal
    direction: str = 'v' #option('v', 'h', default='v')
    levels: IntensityLevels = IntensityLevels(min = 3e3, max = 3e5)
    speed: float = 1000.0
    double: bool = False #double bars

@dataclass
class InputFlickerStepConfigure(InputConfigure):
    # The whole screen changes between specified levels,
    # the pattern of levels is repeated

    # frequency of changing intensity levels
    frequency: float = 20.0
    # intensity levels (can be as many as one wants)
    levels: IntensityLevels = IntensityLevels(min = 3e3, max = 3e5)

@dataclass
class InputNaturalConfigure(InputConfigure):
    # A video is generated by moving a window within an image.
    # Window is changing direction every few hundred ms
    # or if it reaches the image boundary
    image_file: str = 'image1.mat'    # image file
    scale: float = 30000.0        # image scaling factor
    speed: float = 1000.0
    seed: int = 0

@dataclass
class InputGratingsConfigure(InputConfigure):
    x_freq: float = 0.02
    y_freq: float = 0.0
    x_speed: float = 500.0
    y_speed: float = 0.0
    sinusoidal: bool = False
    levels: IntensityLevels = IntensityLevels(min = 3e1, max = 3e4)

@dataclass
class Input:
    screentype: ScreenType = ScreenType.SphereScreen
    inputtype: InputType = InputType.Bar
    screenconfig: Union[CylinderScreen, SphereScreen] = SphereScreen()
    inputconfig: InputConfigure = InputBarConfigure()

    def to_dict(self):
        d = to_dict(self)
        return d

    @classmethod
    def from_dict(cls, d):
        k = from_dict(d)
        if isinstance(k, cls):
            return k
        else:
            raise TypeError('Cannot create an Input instance from the provided dictionary')
            

@dataclass
class Retina:
    rings: int = 14
    radius: float = 1.0   # radius of eye
    # euler angles that describe rotation of retina,
    # should be 3xretina_num
    # approximations: pi: 3.1415, pi/2: 1.5707
    # for cylinder use (0, -1.5707, 0)
    eulerangles: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    acceptance_factor: float = 1.0
    num_microvilli: int = 30000
    numbering_order: str = 'clockwise' # option('clockwise', 'counter_clockwise')
    photoreceptors : List = field(default_factory = lambda: ['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'])
    neuropil_name = 'RET(R)'


